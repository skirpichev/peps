PEP: 9999
Title: Hexadecimal floating-point literals
Author: Sergey B Kirpichev <skirpichev@gmail.com>
Sponsor: Pending
Discussions-To: https://discuss.python.org/t/41848
Status: Draft
Type: Standards Track
Created: 05-Jan-2024
Python-Version: 3.15
Post-History: `25-Dec-2023 <https://discuss.python.org/t/41848>`__


Abstract
========

Add hexadecimal floating-point literals (IEEE 754-2008 ยง5.12.3) and support
construction of floats from hexadecimal strings.


Motivation
==========

The Python supports only decimal floating-point literals.  But underlying
hardware based floating-point numbers are binary, not decimal, and conversion
to and from decimal representation is delicate: it's not obvious which binary
floating-point number represent a given decimal literal.  There are many
different decimal numbers that share the same nearest approximate binary
fraction.  For example, on system where CPython's floats are IEEE 754 binary64:

.. code:: pycon

   >>> (0.1).hex()
   '0x1.999999999999ap-4'
   >>> (0.10000000000000001).hex()
   '0x1.999999999999ap-4'
   >>> (0.1000000000000000055511151231257827021181583404541015625).hex()
   '0x1.999999999999ap-4'

Exact floating-point representations are especially important for reproducible
results --- for instance, while testing "borderline cases" in algorithms.
Because of this, many contemporary languages (e.g. C [1]_, Go [2]_, Julia [3]_,
Java [4]_) introduce hexadecimal floating-point literals [5]_ in source code.
This format also common in the numerical analysis community (see e.g. [6]_ or
the MPFR library [7]_).

Lets accept exact floating-point literals (beyond simple cases like ``0.25``)
as first-class citizens in the language!  Right now the Python include support
(see [8]_) for hexadecimal floats via :external+py3.12:meth:`float.fromhex` and
:external+py3.12:meth:`float.hex` methods, which extensively used in it's test
suite (e.g. to test :mod:`math` and :mod:`random` modules).  But using the
class method to create exact floating-point values is much less convenient,
especially doing interactive work.

This also could be used by some projects in the python ecosystem to enhance
support for multiple precision *binary* floating-point arithmetic in CLI:
hexadecimal floating-point numbers now are valid tokens and can be wrapped by
an appropriate type, e.g. ``gmpy2.mpfr``.  See the `Decimal math
<https://aroberge.github.io/ideas/docs/html/decimal_math.html>`_ example on how
it's possible with decimal floating-point numbers.


Rationale
=========

The argument against might be `like this
<https://github.com/python/cpython/issues/113804#issuecomment-2144011191>`_:

   But we already have :external+py3.12:meth:`float.fromhex`, people can be
   confused by float-savvy syntax like `0x1.a934f0979a371p-2`, while it's easy
   to get detailed explanations by searching for "float.fromhex".

In fact literals even more discoverable, if people are familiar with the basic
syntax of the Python and can recognize assignment or function call.  Just enter
literal expression in the Python REPL and explore the object.  While string
`"0x1.a934f0979a371p-2"` is just... a string, without any special hints from
REPL or your IDE.


Specification
=============

The :external+py3.12:token:`~python-grammar:floatnumber` production rule in the
Python grammar should accept an additional alternative
:token:`~python-grammar:hexfloat` with the following lexical definition:

.. productionlist:: python-grammar
   hexfloat: ("0x | "0X") ["_"] (`hexdigitpart` | `hexpointfloat`) [`binexponent`]
   hexpointfloat: [`hexdigit`] `hexfraction` | `hexdigitpart` "."
   hexfraction: "." `hexdigitpart`
   digitpart: `digit` (["_"] `digit`)*
   hexdigitpart: `hexdigit` (["_"] `hexdigit`)*
   binexponent: ("p" | "P") ["+" | "-"] `digitpart`

The exponent of a hexadecimal floating-point literal is written in decimal, and
it gives the power of 2 by which to multiply the coefficient.

Underscores are acceptable only between digits and after base specifier.

The :class:`float` constructor should accept string input with the
:external+py3.12:token:`~float:floatnumber` production rule, that has an
addtidional alternative :token:`~float:hexfloatnumber`:

.. productionlist:: float
   hexfloatnumber: `~python-grammar:hexinteger` | `~python-grammar:hexpointfloat` | `~python-grammar:hexfloat`

In other words, it should accept any input that is currently accepted by
:external+py3.12:meth:`float.fromhex` method (with ``0x/0X`` prefix being
mandatory), but also allow grouping digits with underscores.


Backwards Compatibility
=======================

New literal syntax introduce a clash with attribute access on hexadecimal
integer literals (e.g. ``0x1.bit_count``), which can be workarounded by putting
braces around the literal (like ``(1).bit_count()``, as it's now required for a
decimal integer).

Now this will issue a :exc:`SyntaxWarning`, which eventually become a
:exc:`SyntaxError`.

While it's possible to workaround this issue during tokenization (there are few
public methods on :class:`int`'s), probably this feature is not very common in
non-interactive coding and it's better to deprecate one.


How to Teach This
=================

The "Floating-point literals" [9]_ section of the Language Reference and the
documentation of the :external+py3.12:class:`float` builtin in the Library
Reference will be expanded to include new syntax rules.


Reference Implementation
========================

A feature-complete CPython implementation is available on Github:
https://github.com/skirpichev/cpython/pull/10


Open Issues
===========

Note also, that new capabilities of the :class:`float` constructor essentially
make the :external+py3.12:meth:`float.fromhex` method redundant (the only
difference is that it doesn't require the hexadecimal base specifier).  The
later could be considered as deprecated.

Maybe it also worth discussing support for binary floating-point literals (in a
similar format as above, like the MPFR does [7]_).  (Together with some string
formatting support in this format.)  This is much less useful from the
practical point of view, but might have education value.


Footnotes
=========

.. [1] since C99, see ยง 6.4.4.2 of the ISO/IEC 9899:1999

.. [2] https://go.dev/ref/spec#Floating-point_literals

.. [3] https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers

.. [4] Java 1.5 onwards, see https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.10.2

.. [5] A hexadecimal floating-point constant is just a shorthand for binary
       scientific notation, when the mantissa part is written in base-16.

.. [6] https://hal.science/hal-00128124v5

.. [7] https://www.mpfr.org/mpfr-4.2.1/mpfr.html#index-mpfr_005fstrtofr

.. [8] https://bugs.python.org/issue3008

.. [9] https://docs.python.org/3.12/reference/lexical_analysis.html#floating-point-literals


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
