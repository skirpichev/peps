PEP: 9999
Title: Hexadecimal floating point literals
Author: Sergey B Kirpichev <skirpichev@gmail.com>
Sponsor: TBD
Discussions-To: https://discuss.python.org/t/41848
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 05-Jan-2024
Python-Version: 3.13
Post-History: `25-Dec-2023 <https://discuss.python.org/t/41848>`__


Abstract
========

Add hexadecimal floating point literals (IEEE 754-2008 ยง5.12.3) and support
construction of floats from hexadecimal strings.


Motivation
==========

The Python supports only decimal floating point literals.  But underlying
hardware based floating point numbers are binary, not decimal, and conversion
to and from decimal representation is delicate: it's not obvious which binary
floating point number represent a given decimal literal.

Exact floating point representations are especially important for reproducible
results --- for instance, while testing "borderline cases" in algorithms.
Because of this, many contemporary languages (e.g. C [1]_, Go [2]_, Julia [3]_,
Java [4]_) introduce hexadecimal floating point literals [5]_ in source code.
This format also common in the numerical analysis community (see e.g. [6]_ or
the MPFR library [7]_).

Lets accept exact floating point literals (beyond simple cases like ``0.25``)
as first-class citizens in the language!  Right now the Python include support
(see [8]_) for hexadecimal floats via :external+py3.12:meth:`float.fromhex` and
:external+py3.12:meth:`float.hex` methods, which extensively used in it's test
suite (e.g. to test :mod:`math` and :mod:`random` modules).  But using the
class method to create exact floating point values much less convenient,
especially doing interactive work.


Specification
=============

The :external+py3.12:token:`~python-grammar:floatnumber` production rule in the
Python grammar should accept an additional alternative
:token:`~python-grammar:hexfloat` with the following lexical definition:

.. productionlist:: python-grammar
   hexfloat: ("0x | "0X") ["_"] (`hexdigitpart`|`hexpointfloat`)`binexponent`
   hexpointfloat: [`hexdigit`]`hexfraction`|`hexdigitpart` "."
   hexfraction: "."`hexdigitpart`
   digitpart:`digit` (["_"]`digit`)*
   hexdigitpart:`hexdigit` (["_"]`hexdigit`)*
   binexponent: ("p" | "P") ["+" | "-"]`digitpart`

The exponent of a hexadecimal floating point literal is written in decimal, and
it gives the power of 2 by which to multiply the coefficient.  Note that the
exponent part is mandatory.

Underscores are acceptable only between digits and after base specifier.

The :class:`float` constructor should accept string input with the
:external+py3.12:token:`~float:floatnumber` production rule, that has an
addtidional alternative :token:`~float:hexfloatnumber`:

.. productionlist:: float
   hexfloatnumber:`~python-grammar:hexinteger`|`~python-grammar:hexpointfloat`|`~python-grammar:hexfloat`

In other words, it should accept any input that is currently accepted by
:external+py3.12:meth:`float.fromhex` method (with ``0x/0X`` prefix being
mandatory), but also allow grouping digits with underscores.


Backwards Compatibility
=======================

New literal syntax introduce a clash with attribute access on hexadecimal
integer literals, which can be workarounded by putting braces around the
literal (like ``(1).bit_count()``, as it's now required for a decimal integer).
However, this happens only for attribute names, matching the following regexp:
``[a-f]*p.*``.  Currently no such attributes exists for the :class:`int` type.


How to Teach This
=================

The "Floating point literals" [9]_ section of the Language Reference and the
documentation of the :external+py3.12:class:`float` builtin in the Library
Reference will be expanded to include new syntax rules.


Reference Implementation
========================

A feature-complete CPython implementation is available on Github:
https://github.com/skirpichev/cpython/tree/hex-floats4


Open Issues
===========

The proposed literal syntax was choosen to match the IEEE 754-2008 and other
languages, that allow hexadecimal floating point literals.  But the exponential
part could be made also optional (as in :external+py3.12:meth:`float.fromhex`
now), at the price that this will introduce a clash with *any* attribute access
on hexadecimal integer literals, including currently existing attributes, e.g.
``0x1.bit_count()`` (now legal) will raise a :exc:`SyntaxError`.  This
alternative syntax could be choosen instead of the proposed one, keeping old
behaviour for an appropriate deprecation period.

Note also, that new capabilities of the :class:`float` constructor essentially
make the :external+py3.12:meth:`float.fromhex` method redundant (the only
difference is that it doesn't require the hexadecimal base specifier).  The
later could be considered as deprecated.

Maybe it also worth discussing support for binary floating point literals (in a
similar format as above, like the MPFR does [7]_).  (Together with some string
formatting support in this format.)  This is much less useful from the
practical point of view, but might have education value.


Footnotes
=========

.. [1] since C99, see ยง 6.4.4.2 of the ISO/IEC 9899:1999

.. [2] https://go.dev/ref/spec#Floating-point_literals

.. [3] https://docs.julialang.org/en/v1/manual/integers-and-floating-point-numbers/#Floating-Point-Numbers

.. [4] Java 1.5 onwards, see https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.10.2

.. [5] A hexadecimal floating point constant is just a shorthand for binary
       scientific notation, when the mantissa part is written in base-16.

.. [6] https://hal.science/hal-00128124v5

.. [7] https://www.mpfr.org/mpfr-4.2.1/mpfr.html#index-mpfr_005fstrtofr

.. [8] https://bugs.python.org/issue3008

.. [9] https://docs.python.org/3.12/reference/lexical_analysis.html#floating-point-literals


Copyright
=========

This document is placed in the public domain or under the CC0-1.0-Universal
license, whichever is more permissive.
